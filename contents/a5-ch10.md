---

## Section 5: Return Values and Chaining

So far, you’ve seen how functions can be used to run blocks of code. But
sometimes, instead of just performing an action like printing to the screen, you
want a function to **return a value** that can be stored, used, or passed along.

### The `return` Keyword

To return a value from a function, use the `return` keyword followed by the
value you want to send back:

```js
function add(a, b) {
  return a + b;
}

let result = add(3, 4);  // result now holds 7
```

Once a function hits `return`, it **immediately stops** and sends the value back
to wherever the function was called.

You can return anything: numbers, strings, objects, even other functions.

```js
function greet(name) {
  return "Hello, " + name + "!";
}

let message = greet("Jordan");
console.log(message);  // Output: Hello, Jordan!
```

> **Helpful Hint:**
> A function that doesn’t use `return` will return `undefined` by default.

### Chaining Function Calls

Sometimes, you can combine or **chain** functions together by using the return value of one function as the input for another.

Example:

```js
function double(n) {
  return n * 2;
}

function square(n) {
  return n * n;
}

let result = square(double(3));  // double(3) is 6, then square(6) is 36
console.log(result);  // Output: 36
```

In the expression above, `double(3)` returns `6`, and that value is passed
directly into `square()`.

This is known as **function composition** — building up more complex behavior
from smaller, single-purpose functions.

### Return Early

It’s often useful to use `return` early in a function to exit under specific
conditions:

```js
function divide(a, b) {
  if (b === 0) {
    return "Cannot divide by zero.";
  }
  return a / b;
}
```

Returning early is a common practice that helps make functions more readable and
safe.

